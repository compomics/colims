package com.compomics.colims.core.io.maxquant;

import java.io.IOException;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.compomics.colims.model.QuantificationFile;
import com.compomics.colims.model.QuantificationGroup;
import com.compomics.colims.model.QuantificationSettings;
import com.compomics.util.experiment.identification.PeptideAssumption;
import com.compomics.util.experiment.identification.SearchParameters;
import com.compomics.util.experiment.identification.matches.ProteinMatch;
import com.compomics.util.experiment.massspectrometry.MSnSpectrum;
import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import org.apache.log4j.Logger;

/**
 * Parser for the text files generated by a <a
 * href="http://maxquant.org/">MaxQuant</a>run. Invokes sub-parsers such as
 * {@link MaxQuantPSMParser} and {@link MaxQuantSpectrumParser} to handle
 * specific files contained in the text folder.
 */
@Service("maxQuantParser")
public class MaxQuantParser {

    private static final Logger LOGGER = Logger.getLogger(MaxQuantParser.class);
    private static final String MSMSTXT = "msms.txt";
    private static final String EVIDENCETXT = "evidence.txt";
    private static final String PROTEINGROUPS = "proteinGroups.txt";
    private static final String PARAMETERS = "parameters.txt";
    private static final String SUMMARY = "summary.txt";
    @Autowired
    private MaxQuantSpectrumParser maxQuantSpectrumParser;
    @Autowired
    private MaxQuantProteinGroupParser maxQuantProteinGroupParser;
    @Autowired
    private MaxQuantPSMParser maxQuantEvidenceParser;
    @Autowired
    private MaxQuantParameterParser maxQuantParameterParser;
    private Map<Integer, PeptideAssumption> peptideAssumptions = new HashMap<>();
    private Map<Integer, MSnSpectrum> msms = new HashMap<>();
    private Map<Integer, ProteinMatch> proteinMap = new HashMap<>();
    private final Map<String, MaxQuantAnalyticalRun> spectraPerRunMap = new HashMap<>();
    private boolean initialized = false;
    private Map<String, SearchParameters> analysisSearchParameters = new HashMap<>();

    /**
     * Parse a folder containing the MaxQuant txt output files, using the
     * correct sub-parser for each known file type.
     *
     * @param maxQuantTextFolder
     * @throws IOException
     */
    public void parseMaxQuantTextFolder(final File maxQuantTextFolder) throws IOException, HeaderEnumNotInitialisedException, UnparseableException {

        //TODO parameters
        // Create a single QuantificationFile file to the argument folder, and store it in the database
        QuantificationFile quantificationFile = new QuantificationFile();
        // TODO Probably store the folder name in quantificationFile, but there are no such fields available
        // Associate the correct QuantificationSettings with this QuantificationFile
        // TODO Actually retrieve or create and store quantificationMethod, but it currently lacks a field for names
        QuantificationSettings quantificationMethod = null;
        quantificationFile.setQuantificationSettings(quantificationMethod);
        // TODO Store quantificationFile; we are currently missing a Hibernate Repository to do so, so skip for now

        // Create a new QuantificationGroup to group all the Quantifications found and link it to the QuantificationFile
        QuantificationGroup quantificationGroup = new QuantificationGroup();
//        quantificationGroup.setQuantificationFile(quantificationFile);
        // TODO Store quantificationGroup; we are currently missing a Hibernate Repository to do so, so skip for now

        // Parse msms.txt and create and persist the objects found within
        LOGGER.debug("starting parameter and summary parsing");
        analysisSearchParameters = maxQuantParameterParser.parse(maxQuantTextFolder);

        LOGGER.debug("starting msms parsing");
        File msmsFile = new File(maxQuantTextFolder, MSMSTXT);
        msms = maxQuantSpectrumParser.parse(msmsFile, true);

        for (MSnSpectrum spectrum : getSpectraFromParsedFile()) {
            if (spectraPerRunMap.containsKey(spectrum.getFileName())) {
                spectraPerRunMap.get(spectrum.getFileName()).addASpectrum(spectrum);
            } else {
                MaxQuantAnalyticalRun maxQuantRun = new MaxQuantAnalyticalRun();
                maxQuantRun.setAnalyticalRunName(spectrum.getFileName());
                maxQuantRun.addASpectrum(spectrum);
                spectraPerRunMap.put((spectrum.getFileName()), maxQuantRun);
            }
        }
        if (spectraPerRunMap.isEmpty()) {
            throw new UnparseableException("could not connect spectra to any run");
        }

        // Parse evidence.txt and create and persist the objects found within
        LOGGER.debug("starting evidence parsing");
        File evidenceFile = new File(maxQuantTextFolder, EVIDENCETXT);
        peptideAssumptions = maxQuantEvidenceParser.parse(evidenceFile);

        //update peptide msms to best scoring msms entry
        LOGGER.debug("starting protein group parsing");
        File proteinGroupsFile = new File(maxQuantTextFolder, PROTEINGROUPS);
        proteinMap = maxQuantProteinGroupParser.parse(proteinGroupsFile);
        if (msms.keySet().isEmpty() || peptideAssumptions.keySet().isEmpty() || proteinMap.keySet().isEmpty()) {
            throw new UnparseableException("one of the parsed files could not be read properly");
        } else {
            initialized = true;
        }
    }

    /**
     * get all the {@code PeptideAssumption}s that were parsed from the max
     * quant folder
     *
     * @return a {@code Collection} of all the {@code PeptideAssumption}s
     */
    public Collection<PeptideAssumption> getIdentificationsFromParsedFile() {
        return Collections.unmodifiableCollection(peptideAssumptions.values());
    }

    public boolean hasParsedAFile() {
        return initialized;
    }

    /**
     * fetch the associated identification with a spectrum, null if not present
     *
     * @param aSpectrum the spectrum to fetch the identification for
     * @return the {@code PeptideAssumption} connected to the spectrum
     * @throws NumberFormatException if the spectrum is not present in the
     * parsed file
     */
    public PeptideAssumption getIdentificationForSpectrum(MSnSpectrum aSpectrum) throws NumberFormatException {
        return peptideAssumptions.get(((SpectrumIntUrParameterShizzleStuff) aSpectrum.getUrParam(new SpectrumIntUrParameterShizzleStuff())).getSpectrumid());
    }

    public Collection<MSnSpectrum> getSpectraFromParsedFile() {
        return Collections.unmodifiableCollection(msms.values());
    }

    public Collection<ProteinMatch> getProteinsFromParsedFile() {
        return Collections.unmodifiableCollection(proteinMap.values());
    }

    /**
     * gets the parsed protein hit that is the most likely according to max
     * quant for the parsed identification
     *
     * @param aPeptideAssumption the identification to get the protein for
     * @return the protein with the best association for the given parsed
     * identification
     * @throws NumberFormatException if the identification is not present in the
     * parsed files
     */
    public ProteinMatch getBestProteinHitForIdentification(PeptideAssumption aPeptideAssumption) throws NumberFormatException {
        return proteinMap.get(Integer.parseInt(aPeptideAssumption.getPeptide().getParentProteinsNoRemapping().get(0)));
    }

    public Collection<ProteinMatch> getProteinHitsForIdentification(PeptideAssumption aPeptideAssumption) throws NumberFormatException {
        Collection<ProteinMatch> proteins = new ArrayList<>();
        for (String proteinKey : aPeptideAssumption.getPeptide().getParentProteinsNoRemapping()) {
            proteins.add(proteinMap.get(Integer.parseInt(proteinKey)));
        }
        return Collections.unmodifiableCollection(proteins);
    }

    public Collection<MaxQuantAnalyticalRun> getRuns() {
        return Collections.unmodifiableCollection(spectraPerRunMap.values());
    }

    public SearchParameters getParametersForRun(MaxQuantAnalyticalRun aParsedRun) {
        return analysisSearchParameters.get(aParsedRun.getAnalyticalRunName());
    }

    public void clearParsedProject() {
        msms.clear();
        peptideAssumptions.clear();
        proteinMap.clear();
        spectraPerRunMap.clear();
        analysisSearchParameters.clear();
        initialized = false;
    }
}
