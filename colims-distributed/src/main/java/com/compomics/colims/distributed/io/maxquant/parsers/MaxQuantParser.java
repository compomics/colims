package com.compomics.colims.distributed.io.maxquant.parsers;

import com.compomics.colims.distributed.io.maxquant.MaxQuantConstants;
import com.compomics.colims.distributed.io.maxquant.UnparseableException;
import com.compomics.colims.model.*;
import com.compomics.colims.model.enums.FastaDbType;
import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;

//// TODO: 6/1/2016 make youtrack entry to separate concerns between mapper and parser class, i.e. remove all setting to parser class from mapper class

/**
 * Parser for the text files generated by a
 * <a href="http://maxquant.org/">MaxQuant</a>run. Invokes sub-parsers such as
 * {@link MaxQuantEvidenceParser} and {@link MaxQuantSpectraParser} to handle
 * specific files contained in the text folder.
 */
@Component("maxQuantParser")
public class MaxQuantParser {

    /**
     * Logger instance.
     */
    private static final Logger LOGGER = Logger.getLogger(MaxQuantParser.class);

    /**
     * The map of analytical runs (key: run name; value: the {@link AnalyticalRun} instance);
     */
    private final Map<String, AnalyticalRun> analyticalRuns = new HashMap<>();
    /**
     * The child parsers.
     */
    private final MaxQuantSpectraParser maxQuantSpectraParser;
    private final MaxQuantProteinGroupsParser maxQuantProteinGroupsParser;
    private final MaxQuantEvidenceParser maxQuantEvidenceParser;
    private final MaxQuantSearchSettingsParser maxQuantSearchSettingsParser;

    @Autowired
    public MaxQuantParser(MaxQuantSpectraParser maxQuantSpectraParser,
                          MaxQuantProteinGroupsParser maxQuantProteinGroupsParser,
                          MaxQuantEvidenceParser maxQuantEvidenceParser,
                          MaxQuantSearchSettingsParser maxQuantSearchSettingsParser) {
        this.maxQuantSpectraParser = maxQuantSpectraParser;
        this.maxQuantProteinGroupsParser = maxQuantProteinGroupsParser;
        this.maxQuantEvidenceParser = maxQuantEvidenceParser;
        this.maxQuantSearchSettingsParser = maxQuantSearchSettingsParser;
    }

    /**
     * Clear the parser.
     */
    public void clear() {
        analyticalRuns.clear();
        maxQuantEvidenceParser.clear();
        maxQuantSpectraParser.clear();
        maxQuantProteinGroupsParser.clear();
        maxQuantSearchSettingsParser.clear();
    }

    /**
     * Parse the MaxQuant output folder and map the content of the different
     * files to Colims entities.
     *
     * @param maxQuantDirectory          File pointer to MaxQuant directory
     * @param fastaDbs                   the FASTA database map (key: FastaDb type; value: FastaDb instance)
     * @param includeContaminants        whether to import proteins from contaminants file.
     * @param includeUnidentifiedSpectra whether to import unidentified spectra from APL files.
     * @param optionalHeaders            list of optional headers to store in protein group quantification labeled
     *                                   table.
     * @throws IOException          in case of an input/output related problem
     * @throws UnparseableException in case of a problem occured while parsing
     */
    public void parse(Path maxQuantDirectory, EnumMap<FastaDbType, List<FastaDb>> fastaDbs, boolean includeContaminants,
                      boolean includeUnidentifiedSpectra, List<String> optionalHeaders) throws IOException, UnparseableException {

        //look for the MaxQuant txt directory
        Path txtDirectory = Paths.get(maxQuantDirectory.toString() + File.separator + MaxQuantConstants.TXT_DIRECTORY.value());
        if (!Files.exists(txtDirectory)) {
            throw new FileNotFoundException("The MaxQuant txt file " + txtDirectory.toString() + " was not found.");
        }

        //populate the analytical runs map
        maxQuantSearchSettingsParser.getAnalyticalRuns().forEach((k, v) -> analyticalRuns.put(k.getName(), k));

        //first, parse the protein groups file
        LOGGER.debug("parsing proteinGroups.txt");
        List<FastaDb> fastaDbList = new ArrayList<>();
        fastaDbs.forEach((k, v) -> {
            v.forEach(fastaDb -> {
                fastaDbList.add(fastaDb);
            });
        });

        //look for the proteinGroups.txt file
        Path proteinGroupsFile = Paths.get(txtDirectory.toString(), MaxQuantConstants.PROTEIN_GROUPS_FILE.value());
        if (!Files.exists(proteinGroupsFile)) {
            throw new FileNotFoundException("The proteinGroups.txt " + proteinGroupsFile.toString() + " was not found.");
        }
        maxQuantProteinGroupsParser.parse(proteinGroupsFile, fastaDbList, includeContaminants, optionalHeaders);

        LOGGER.debug("parsing msms.txt");
        maxQuantSpectraParser.parse(maxQuantDirectory, includeUnidentifiedSpectra, maxQuantProteinGroupsParser.getOmittedProteinGroupIds());

        LOGGER.debug("parsing evidence.txt");
        Path evidenceFile = Paths.get(txtDirectory.toString(), MaxQuantConstants.EVIDENCE_FILE.value());
        if (!Files.exists(evidenceFile)) {
            throw new FileNotFoundException("The evidence.txt " + evidenceFile.toString() + " was not found.");
        }
        maxQuantEvidenceParser.parse(evidenceFile, maxQuantProteinGroupsParser.getOmittedProteinGroupIds());

        //add the identified spectra for each run and set the entity relations
        analyticalRuns.forEach((runName, run) -> {
            //get the spectrum apl keys for each run
            List<String> aplKeys = maxQuantSpectraParser.getMaxQuantSpectra().getRunToSpectrums().get(runName);
            aplKeys.forEach(aplKey -> {
                //get the spectrum by it's key
                Spectrum spectrum = maxQuantSpectraParser.getMaxQuantSpectra().getSpectra().get(aplKey);

                //set the entity relations between run and spectrum
                run.getSpectrums().add(spectrum);
                spectrum.setAnalyticalRun(run);

                //set the child entity relations for the spectrum
                setSpectrumRelations(aplKey, spectrum);
            });
        });

        //add the unidentified spectra for each run
        getUnidentifiedSpectra().forEach((runName, spectrum) -> analyticalRuns.get(runName).getSpectrums().addAll(spectrum));

        if (getSpectrumToPsms().isEmpty() || maxQuantEvidenceParser.getSpectrumToPeptides().isEmpty() || maxQuantProteinGroupsParser.getProteinGroups().isEmpty()) {
            throw new UnparseableException("One of the parsed files could not be read properly.");
        }
    }

    /**
     * Get the map that links the apl spectra with msms.txt entries (key: apl key; value:).
     *
     * @return the link map
     */
    public Map<String, List<Integer>> getSpectrumToPsms() {
        return maxQuantSpectraParser.getMaxQuantSpectra().getSpectrumToPsms();
    }

    /**
     * Return a list copy of the spectra per run map values.
     *
     * @return Collection of runs
     */
    public List<AnalyticalRun> getRuns() {
        return analyticalRuns.values().stream().collect(Collectors.toList());
    }

    /**
     * Get the protein groups as a set.
     *
     * @return the protein group set
     */
    public Set<ProteinGroup> getProteinGroupSet() {
        return maxQuantProteinGroupsParser.getProteinGroups().values().stream().collect(Collectors.toSet());
    }

    /**
     * Create the necessary relationships for the children of a spectrum.
     *
     * @param aplKey   the apl spectrum key
     * @param spectrum the {@link Spectrum} instance
     */
    private void setSpectrumRelations(String aplKey, Spectrum spectrum) {
        //get the msms.txt IDs associated with the given spectrum
        List<Integer> msmsIds = maxQuantSpectraParser.getMaxQuantSpectra().getSpectrumToPsms().get(aplKey);
        for (Integer msmsId : msmsIds) {
            //get the evidence IDs associated with the msms ID
            for (Integer evidenceId : maxQuantEvidenceParser.getSpectrumToPeptides().get(msmsId)) {
                //get the peptide by it's evidence ID
                Peptide peptide = maxQuantEvidenceParser.getPeptides().get(evidenceId);

                //get the protein groups IDs for each peptide
                List<Integer> proteinGroupIds = maxQuantEvidenceParser.getPeptideToProteinGroups().get(evidenceId);

                proteinGroupIds.forEach(proteinGroupId -> {
                    //get the protein group by it's ID
                    ProteinGroup proteinGroup = maxQuantProteinGroupsParser.getProteinGroups().get(proteinGroupId);

                    PeptideHasProteinGroup peptideHasProteinGroup = new PeptideHasProteinGroup();
                    peptideHasProteinGroup.setPeptidePostErrorProbability(peptide.getPsmPostErrorProbability());
                    peptideHasProteinGroup.setPeptideProbability(peptide.getPsmProbability());
                    peptideHasProteinGroup.setPeptide(peptide);
                    peptideHasProteinGroup.setProteinGroup(proteinGroup);

                    proteinGroup.getPeptideHasProteinGroups().add(peptideHasProteinGroup);
                    //set peptideHasProteinGroups in peptide
                    peptide.getPeptideHasProteinGroups().add(peptideHasProteinGroup);
                });

                //set entity relations between Spectrum and Peptide
                spectrum.getPeptides().add(peptide);
                peptide.setSpectrum(spectrum);
            }
        }
    }

    /**
     * Get the unidentified spectra.
     *
     * @return the unidentified spectra list.
     */
    private Map<String, List<Spectrum>> getUnidentifiedSpectra() {
        return maxQuantSpectraParser.getMaxQuantSpectra().getUnidentifiedSpectra();
    }

}
