package com.compomics.colims.distributed.io.maxquant.parsers;

import com.compomics.colims.distributed.io.maxquant.MaxQuantConstants;
import com.compomics.colims.distributed.io.maxquant.UnparseableException;
import com.compomics.colims.model.*;
import com.compomics.colims.model.enums.FastaDbType;
import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;

//// TODO: 6/1/2016 make youtrack entry to separate concerns between mapper and parser class, i.e. remove all setting to parser class from mapper class

/**
 * Parser for the text files generated by a
 * <a href="http://maxquant.org/">MaxQuant</a>run. Invokes sub-parsers such as
 * {@link MaxQuantEvidenceParser} and {@link MaxQuantSpectraParser} to handle
 * specific files contained in the text folder.
 */
@Component("maxQuantParser")
public class MaxQuantParser {

    /**
     * Logger instance.
     */
    private static final Logger LOGGER = Logger.getLogger(MaxQuantParser.class);

    private Map<Integer, ProteinGroup> proteinGroups = new HashMap<>();
    private final Map<String, AnalyticalRun> analyticalRuns = new HashMap<>();
    /**
     * The child parsers.
     */
    private final MaxQuantSpectraParser maxQuantSpectraParser;
    private final MaxQuantProteinGroupsParser maxQuantProteinGroupsParser;
    private final MaxQuantEvidenceParser maxQuantEvidenceParser;
    private final MaxQuantSearchSettingsParser maxQuantSearchSettingsParser;

    @Autowired
    public MaxQuantParser(MaxQuantSpectraParser maxQuantSpectraParser,
                          MaxQuantProteinGroupsParser maxQuantProteinGroupsParser,
                          MaxQuantEvidenceParser maxQuantEvidenceParser,
                          MaxQuantSearchSettingsParser maxQuantSearchSettingsParser) {
        this.maxQuantSpectraParser = maxQuantSpectraParser;
        this.maxQuantProteinGroupsParser = maxQuantProteinGroupsParser;
        this.maxQuantEvidenceParser = maxQuantEvidenceParser;
        this.maxQuantSearchSettingsParser = maxQuantSearchSettingsParser;
    }

    /**
     * Clear the parser.
     */
    public void clear() {
        proteinGroups.clear();
        analyticalRuns.clear();
        maxQuantEvidenceParser.clear();
        maxQuantSpectraParser.clear();
        maxQuantProteinGroupsParser.clear();
        maxQuantSearchSettingsParser.clear();
    }

    /**
     * Parse the MaxQuant output folder and map the content of the different
     * files to Colims entities.
     *
     * @param maxQuantDirectory          File pointer to MaxQuant directory
     * @param fastaDbs                   the FASTA database map (key: FastaDb type; value: FastaDb instance)
     * @param includeContaminants        whether to import proteins from contaminants file.
     * @param includeUnidentifiedSpectra whether to import unidentified spectra from APL files.
     * @param optionalHeaders            list of optional headers to store in protein group quantification labeled
     *                                   table.
     * @throws IOException          in case of an input/output related problem
     * @throws UnparseableException in case of a problem occured while parsing
     */
    public void parse(Path maxQuantDirectory, EnumMap<FastaDbType, List<FastaDb>> fastaDbs, boolean includeContaminants,
                      boolean includeUnidentifiedSpectra, List<String> optionalHeaders) throws IOException, UnparseableException {
        //look for the MaxQuant txt directory
        Path txtDirectory = Paths.get(maxQuantDirectory.toString() + File.separator + MaxQuantConstants.TXT_DIRECTORY.value());
        if (!Files.exists(txtDirectory)) {
            throw new FileNotFoundException("The MaxQuant txt file " + txtDirectory.toString() + " was not found.");
        }
        //analyticalRuns.clear(); check if analytical run map is empty?
        maxQuantSearchSettingsParser.getAnalyticalRuns().forEach((k, v) -> analyticalRuns.put(k.getName(), k));

        //first, parse the protein groups file
        LOGGER.debug("parsing proteinGroups.txt");
        List<FastaDb> fastaDbList = new ArrayList<>();
        fastaDbs.forEach((k, v) -> {
            v.forEach(fastaDb -> {
                fastaDbList.add(fastaDb);
            });
        });

        //look for the proteinGroups.txt file
        Path proteinGroupsFile = Paths.get(txtDirectory.toString(), MaxQuantConstants.PROTEIN_GROUPS_FILE.value());
        if (!Files.exists(proteinGroupsFile)) {
            throw new FileNotFoundException("The proteinGroups.txt " + proteinGroupsFile.toString() + " was not found.");
        }
        proteinGroups = maxQuantProteinGroupsParser.parse(proteinGroupsFile, fastaDbList, includeContaminants, optionalHeaders);

        LOGGER.debug("parsing msms.txt");
        maxQuantSpectraParser.parse(maxQuantDirectory, includeUnidentifiedSpectra, maxQuantProteinGroupsParser.getOmittedProteinGroupIds());
        //set spectra for analytical runs where spectra comes from the msms.txt file
        getSpectra().keySet().forEach(spectrum -> {
            //get the raw file titles from the spectrum titles
            String rawFile = spectrum.getTitle().split("--")[0];
            if (analyticalRuns.containsKey(rawFile)) {
                analyticalRuns.get(rawFile).getSpectrums().add(spectrum);
            } else {
                AnalyticalRun analyticalRun = new AnalyticalRun();
                analyticalRun.setName(rawFile);
                analyticalRun.getSpectrums().add(spectrum);

                analyticalRuns.put(rawFile, analyticalRun);
            }
        });
        //set unidentified spectra for analytical runs
        getUnidentifiedSpectra().forEach(unidentifiedSpectrum -> {
            Optional foundKey = analyticalRuns.keySet().stream()
                    .filter(runKey -> unidentifiedSpectrum.getAccession().contains(runKey))
                    .findFirst();
            if (foundKey.isPresent()) {
                analyticalRuns.get(foundKey.get()).getSpectrums().add(unidentifiedSpectrum);
            }
        });

        if (analyticalRuns.isEmpty()) {
            throw new UnparseableException("could not connect spectra to any run");
        }

        LOGGER.debug("parsing evidence.txt");
        Path evidenceFile = Paths.get(txtDirectory.toString(), MaxQuantConstants.EVIDENCE_FILE.value());
        if (!Files.exists(evidenceFile)) {
            throw new FileNotFoundException("The evidence.txt " + evidenceFile.toString() + " was not found.");
        }
        maxQuantEvidenceParser.parse(evidenceFile, maxQuantProteinGroupsParser.getOmittedProteinGroupIds());

        if (getSpectra().isEmpty() || maxQuantEvidenceParser.getSpectrumToPeptides().isEmpty() || proteinGroups.isEmpty()) {
            throw new UnparseableException("one of the parsed files could not be read properly");
        }
    }

    /**
     * Fetch the identification(s) associated with a spectrum.
     *
     * @param spectrum the spectrum
     * @return the peptide(s) connected to the spectrum
     * @throws NumberFormatException if the spectrum is not present in the parsed file
     */
    public List<Peptide> getIdentificationForSpectrum(Spectrum spectrum) throws NumberFormatException {
        // TODO: 6/1/2016 move peptide list to this class.
        List<Integer> spectrumKeys = getSpectra().get(spectrum);
        List<Peptide> peptideList = new ArrayList<>();
        if (spectrumKeys != null) {
            for (int spectrumKey : spectrumKeys) {
                if (!maxQuantEvidenceParser.getSpectrumToPeptides().isEmpty()) {
                    peptideList.addAll(maxQuantEvidenceParser.getSpectrumToPeptides().get(spectrumKey));
                } else {
                    throw new java.lang.IllegalStateException("At this stage peptides map is empty.");
                }
            }
        }
        return peptideList;
    }

    /**
     * Return a copy of the spectra map.
     *
     * @return Map of ids and spectra
     */
    public Map<Spectrum, List<Integer>> getSpectra() {
        return Collections.unmodifiableMap(maxQuantSpectraParser.getMaxQuantSpectra().getSpectrumToMsmsIds());
    }

    /**
     * Return a copy of the unidentified spectra list.
     *
     * @return unidentified spectra list.
     */
    private List<Spectrum> getUnidentifiedSpectra() {
        return Collections.unmodifiableList(maxQuantSpectraParser.getMaxQuantSpectra().getUnidentifiedSpectra());
    }

    /**
     * Return a list of protein group matches for a peptide
     *
     * @param peptide the given {@link Peptide} instance
     * @return Collection of protein groups
     * @throws NumberFormatException thrown in case of a String to numeric format conversion error.
     */
    public List<ProteinGroup> getProteinHitsForIdentification(Peptide peptide) throws NumberFormatException {
        List<ProteinGroup> peptideProteinGroups = maxQuantEvidenceParser.getPeptideToProteins().get(peptide)
                .stream()
                .map(proteinGroups::get)
                .collect(Collectors.toList());

        peptideProteinGroups.removeIf(p -> p == null);

        return peptideProteinGroups;
    }

    /**
     * Return a list copy of the spectra per run map values.
     *
     * @return Collection of runs
     */
    public Collection<AnalyticalRun> getRuns() {
        return Collections.unmodifiableCollection(analyticalRuns.values());
    }

    /**
     * Get the protein groups as a set.
     *
     * @return the protein group set
     */
    public Set<ProteinGroup> getProteinGroupSet() {
        return proteinGroups.values().stream().collect(Collectors.toSet());
    }

}
